// Jogo Educativo de Sustentabilidade em SDL2
// Adaptação do jogo educativo da professora/pedagoga Silvia
// Cada opção abre um "tile" temático + quiz + botão para voltar
// Merge final: tiles, botões, quiz, vídeo simulado, SDL_WaitEventTimeout
// Assets: tile_menu.png, tile_agua.png, tile_energia.png, tile_meioambiente.png
// botao_play.png, botao_voltar.png, botao_sim.png, botao_nao.png, botao_agua.png, botao_energia.png, botao_meioambiente.png
// fonte: assets/DejaVuSans.ttf (ou FreeSans.ttf)

#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_mixer.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define LARG 1000
#define ALT 600
#define TIMEOUT_MS 16
#define MAX_PERG 10

typedef enum {
    EST_MENU,
    EST_TEMA_AGUA,
    EST_TEMA_ENERGIA,
    EST_TEMA_MEIO,
    EST_VIDEO,
    EST_QUIT
} Estado;

// Estrutura de pergunta (duas alternativas A/B por simplicidade)
typedef struct {
    char pergunta[256];
    char a[128];
    char b[128];
    char correta; // 'A' ou 'B'
} Pergunta;

// -------------------------
// Variáveis globais (simples)
// -------------------------
SDL_Window *janela = NULL;
SDL_Renderer *render = NULL;
TTF_Font *fonte = NULL;
Mix_Chunk *som_certo = NULL;
Mix_Chunk *som_errado = NULL;

// Texturas (carregar uma vez)
SDL_Texture *tex_tile_menu = NULL;
SDL_Texture *tex_tile_agua = NULL;
SDL_Texture *tex_tile_energia = NULL;
SDL_Texture *tex_tile_meio = NULL;

SDL_Texture *tex_btn_play = NULL;
SDL_Texture *tex_btn_voltar = NULL;
SDL_Texture *tex_btn_tema_agua = NULL;
SDL_Texture *tex_btn_tema_energia = NULL;
SDL_Texture *tex_btn_tema_meio = NULL;
SDL_Texture *tex_btn_sim = NULL;
SDL_Texture *tex_btn_nao = NULL;

// Retângulos de botão no menu (posição fixa)
SDL_Rect r_play = {400, 300, 200, 80};
SDL_Rect r_tema_agua = {100, 450, 200, 80};
SDL_Rect r_tema_energia = {400, 450, 200, 80};
SDL_Rect r_tema_meio = {700, 450, 200, 80};
SDL_Rect r_voltar = {20, 20, 150, 60};
SDL_Rect r_sim = {300, 360, 200, 80};
SDL_Rect r_nao = {500, 360, 200, 80};

// Perguntas (exemplo: 10 por tema)
Pergunta perguntas_agua[MAX_PERG];
Pergunta perguntas_energia[MAX_PERG];
Pergunta perguntas_meio[MAX_PERG];

// quiz atual (embaralhado)
Pergunta quiz_atual[MAX_PERG];

// -------------------------
// Utilitários
// -------------------------
SDL_Texture* carregar_textura(const char *caminho) {
    SDL_Surface *s = IMG_Load(caminho);
    if (!s) {
        fprintf(stderr, "IMG_Load('%s') erro: %s\n", caminho, IMG_GetError());
        return NULL;
    }
    SDL_Texture *t = SDL_CreateTextureFromSurface(render, s);
    SDL_FreeSurface(s);
    return t;
}

SDL_Texture* cria_textura_texto(const char *msg, SDL_Color cor) {
    if (!fonte) return NULL;
    SDL_Surface *surf = TTF_RenderUTF8_Blended(fonte, msg, cor);
    if (!surf) return NULL;
    SDL_Texture *tex = SDL_CreateTextureFromSurface(render, surf);
    SDL_FreeSurface(surf);
    return tex;
}

// desenha textura com fallback para texto (caso tex == NULL)
void desenhar_botao_com_textura(SDL_Texture *tex, const char *texto, SDL_Rect dst) {
    if (tex) {
        SDL_RenderCopy(render, tex, NULL, &dst);
    } else {
        // retângulo de fundo
        SDL_SetRenderDrawColor(render, 20, 110, 80, 255);
        SDL_RenderFillRect(render, &dst);
        // texto centralizado
        SDL_Color branco = {255,255,255,255};
        SDL_Texture *t = cria_textura_texto(texto, branco);
        if (t) {
            int w,h; SDL_QueryTexture(t, NULL, NULL, &w, &h);
            SDL_Rect r = { dst.x + (dst.w - w)/2, dst.y + (dst.h - h)/2, w, h };
            SDL_RenderCopy(render, t, NULL, &r);
            SDL_DestroyTexture(t);
        }
    }
}

// verifica se (x,y) está dentro do rect
bool dentro_rect(SDL_Rect r, int x, int y) {
    return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;
}

// imprime mensagem de erro e retorna false
bool checar_init(bool cond, const char *msg) {
    if (!cond) {
        fprintf(stderr, "%s\n", msg);
        return false;
    }
    return true;
}

// -------------------------
// Banco de perguntas
// -------------------------
void criar_perguntas_exemplos() {
    // Água (10)
    strcpy(perguntas_agua[0].pergunta, "Tomar banho mais curto economiza água?");
    strcpy(perguntas_agua[0].a, "Sim");
    strcpy(perguntas_agua[0].b, "Não");
    perguntas_agua[0].correta = 'A';

    strcpy(perguntas_agua[1].pergunta, "Fechar a torneira ao escovar os dentes economiza?");
    strcpy(perguntas_agua[1].a, "Sim");
    strcpy(perguntas_agua[1].b, "Não");
    perguntas_agua[1].correta = 'A';

    strcpy(perguntas_agua[2].pergunta, "Reaproveitar água da chuva é adequado para beber?");
    strcpy(perguntas_agua[2].a, "Sim");
    strcpy(perguntas_agua[2].b, "Não");
    perguntas_agua[2].correta = 'B';

    strcpy(perguntas_agua[3].pergunta, "Vazamentos aumentam desperdício de água?");
    strcpy(perguntas_agua[3].a, "Sim");
    strcpy(perguntas_agua[3].b, "Não");
    perguntas_agua[3].correta = 'A';

    strcpy(perguntas_agua[4].pergunta, "Regar plantas ao entardecer reduz perda por evaporação?");
    strcpy(perguntas_agua[4].a, "Sim");
    strcpy(perguntas_agua[4].b, "Não");
    perguntas_agua[4].correta = 'A';

    strcpy(perguntas_agua[5].pergunta, "Lavar carro com balde gasta menos água que mangueira?");
    strcpy(perguntas_agua[5].a, "Sim");
    strcpy(perguntas_agua[5].b, "Não");
    perguntas_agua[5].correta = 'A';

    strcpy(perguntas_agua[6].pergunta, "Água potável é a maior parte da água do planeta?");
    strcpy(perguntas_agua[6].a, "Sim");
    strcpy(perguntas_agua[6].b, "Não");
    perguntas_agua[6].correta = 'B';

    strcpy(perguntas_agua[7].pergunta, "Cobrir piscina reduz evaporação?");
    strcpy(perguntas_agua[7].a, "Sim");
    strcpy(perguntas_agua[7].b, "Não");
    perguntas_agua[7].correta = 'A';

    strcpy(perguntas_agua[8].pergunta, "Economizar água ajuda a conservar ecossistemas?");
    strcpy(perguntas_agua[8].a, "Sim");
    strcpy(perguntas_agua[8].b, "Não");
    perguntas_agua[8].correta = 'A';

    strcpy(perguntas_agua[9].pergunta, "Torneiras pingando geram pequeno desperdício?");
    strcpy(perguntas_agua[9].a, "Não");
    strcpy(perguntas_agua[9].b, "Sim");
    perguntas_agua[9].correta = 'B';

    // Energia (10) — exemplos simples
    for (int i = 0; i < MAX_PERG; i++) {
        sprintf(perguntas_energia[i].pergunta, "Exemplo energia pergunta %d?", i+1);
        strcpy(perguntas_energia[i].a, "Sim");
        strcpy(perguntas_energia[i].b, "Não");
        perguntas_energia[i].correta = (i % 2 == 0) ? 'A' : 'B';
    }

    // Meio ambiente (10) — exemplos simples
    for (int i = 0; i < MAX_PERG; i++) {
        sprintf(perguntas_meio[i].pergunta, "Exemplo meio pergunta %d?", i+1);
        strcpy(perguntas_meio[i].a, "Sim");
        strcpy(perguntas_meio[i].b, "Não");
        perguntas_meio[i].correta = (i % 2 == 0) ? 'A' : 'B';
    }
}

// Embaralha e copia MAX_PERG perguntas para quiz_atual
void sortear_perguntas(Pergunta origem[MAX_PERG]) {
    for (int i = 0; i < MAX_PERG; i++) quiz_atual[i] = origem[i];
    // Fisher-Yates
    for (int i = MAX_PERG - 1; i > 0; i--) {
        int j = rand() % (i+1);
        Pergunta tmp = quiz_atual[i];
        quiz_atual[i] = quiz_atual[j];
        quiz_atual[j] = tmp;
    }
}

// -------------------------
// Função quiz (10 perguntas A/B)
// Antes de executar, já deve ter sido desenhado o tile do tema.
// Mantém o tile do tema durante todo o quiz e depois mantém até o "Voltar".
// retorna pontos (0..MAX_PERG)
int executar_quiz_com_tile(SDL_Texture *tile, const char *titulo, Pergunta banco[MAX_PERG]) {
    SDL_Event e;
    int pontos = 0;
    int idx = 0;

    // sortear
    sortear_perguntas(banco);

    // desenhar tile + título inicial antes do quiz
    if (tile) {
        SDL_RenderCopy(render, tile, NULL, NULL);
    } else {
        SDL_SetRenderDrawColor(render, 30, 30, 30, 255);
        SDL_RenderClear(render);
    }
    SDL_Color branco = {255,255,255,255};
    SDL_Texture *t = cria_textura_texto(titulo, branco);
    if (t) {
        int w,h; SDL_QueryTexture(t, NULL, NULL, &w, &h);
        SDL_Rect rt = { (LARG-w)/2, 60, w, h };
        SDL_RenderCopy(render, t, NULL, &rt);
        SDL_DestroyTexture(t);
    }
    SDL_RenderPresent(render);
    SDL_Delay(200); // pequena pausa visual

    // Para cada pergunta
    while (idx < MAX_PERG) {
        // desenha pergunta e botões sobre o tile
        if (tile) SDL_RenderCopy(render, tile, NULL, NULL);
        else { SDL_SetRenderDrawColor(render, 30,30,30,255); SDL_RenderClear(render); }

        // texto pergunta
        SDL_Color cor = {255,255,255,255};
        SDL_Texture *tp = cria_textura_texto(quiz_atual[idx].pergunta, cor);
        if (tp) {
            int w,h; SDL_QueryTexture(tp, NULL, NULL, &w, &h);
            SDL_Rect rp = { (LARG-w)/2, 150, w, h };
            SDL_RenderCopy(render, tp, NULL, &rp);
            SDL_DestroyTexture(tp);
        }

        // desenhar botões Sim/Não (usar texturas se existirem)
        desenhar_botao_com_textura(tex_btn_sim, quiz_atual[idx].a, r_sim);
        desenhar_botao_com_textura(tex_btn_nao, quiz_atual[idx].b, r_nao);

        // exibe barra de progresso (perguntas respondidas)
        char buf[64];
        sprintf(buf, "Pergunta %d de %d", idx+1, MAX_PERG);
        SDL_Texture *tprog = cria_textura_texto(buf, cor);
        if (tprog) {
            int w,h; SDL_QueryTexture(tprog, NULL, NULL, &w, &h);
            SDL_Rect rp = { (LARG-w)/2, 260, w, h };
            SDL_RenderCopy(render, tprog, NULL, &rp);
            SDL_DestroyTexture(tprog);
        }

        // desenha botão voltar (por segurança durante quiz)
        desenhar_botao_com_textura(tex_btn_voltar, "Voltar", r_voltar);

        SDL_RenderPresent(render);

        // aguardar resposta (evento)
        bool respondeu = false;
        while (!respondeu) {
            if (SDL_WaitEventTimeout(&e, TIMEOUT_MS)) {
                if (e.type == SDL_QUIT) return pontos;
                if (e.type == SDL_KEYDOWN) {
                    if (e.key.keysym.sym == SDLK_1) { // tecla 1 -> Sim (A)
                        if (quiz_atual[idx].correta == 'A') { pontos++; if (som_certo) Mix_PlayChannel(-1, som_certo, 0); }
                        else { if (som_errado) Mix_PlayChannel(-1, som_errado, 0); }
                        respondeu = true;
                        idx++;
                        break;
                    }
                    if (e.key.keysym.sym == SDLK_2) { // tecla 2 -> Não (B)
                        if (quiz_atual[idx].correta == 'B') { pontos++; if (som_certo) Mix_PlayChannel(-1, som_certo, 0); }
                        else { if (som_errado) Mix_PlayChannel(-1, som_errado, 0); }
                        respondeu = true;
                        idx++;
                        break;
                    }
                    if (e.key.keysym.sym == SDLK_ESCAPE) return pontos;
                }
                if (e.type == SDL_MOUSEBUTTONDOWN) {
                    int mx = e.button.x, my = e.button.y;
                    // Sim
                    if (dentro_rect(r_sim, mx, my)) {
                        if (quiz_atual[idx].correta == 'A') { pontos++; if (som_certo) Mix_PlayChannel(-1, som_certo, 0); }
                        else { if (som_errado) Mix_PlayChannel(-1, som_errado, 0); }
                        respondeu = true; idx++; break;
                    }
                    // Não
                    if (dentro_rect(r_nao, mx, my)) {
                        if (quiz_atual[idx].correta == 'B') { pontos++; if (som_certo) Mix_PlayChannel(-1, som_certo, 0); }
                        else { if (som_errado) Mix_PlayChannel(-1, som_errado, 0); }
                        respondeu = true; idx++; break;
                    }
                    // Voltar (durante quiz volta imediatamente)
                    if (dentro_rect(r_voltar, mx, my)) {
                        return pontos;
                    }
                }
            }
            // redrawing continuo para manter animações (se houver)
        }
        SDL_Delay(150); // pequena pausa entre perguntas
    }

    // mostra resultado final por 1.2s e depois retorna (tile ainda visível)
    if (tile) SDL_RenderCopy(render, tile, NULL, NULL);
    else { SDL_SetRenderDrawColor(render, 30,30,30,255); SDL_RenderClear(render); }

    char buf2[128];
    sprintf(buf2, "Quiz concluído! Pontuação: %d / %d", pontos, MAX_PERG);
    SDL_Texture *tres = cria_textura_texto(buf2, (SDL_Color){255,255,255,255});
    if (tres) {
        int w,h; SDL_QueryTexture(tres, NULL, NULL, &w, &h);
        SDL_Rect r = { (LARG-w)/2, 200, w, h };
        SDL_RenderCopy(render, tres, NULL, &r);
        SDL_DestroyTexture(tres);
    }
    // desenha botão voltar para permitir retorno
    desenhar_botao_com_textura(tex_btn_voltar, "Voltar", r_voltar);
    SDL_RenderPresent(render);

    // esperar clique em voltar ou ESC
    bool espera = true;
    while (espera) {
        if (SDL_WaitEventTimeout(&e, TIMEOUT_MS)) {
            if (e.type == SDL_QUIT) return pontos;
            if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE) return pontos;
            if (e.type == SDL_MOUSEBUTTONDOWN) {
                int mx = e.button.x, my = e.button.y;
                if (dentro_rect(r_voltar, mx, my)) espera = false;
            }
        }
    }

    return pontos;
}

// -------------------------
// Render páginas (menu e tema)
// -------------------------
void renderizar_menu() {
    // fundo
    if (tex_tile_menu) SDL_RenderCopy(render, tex_tile_menu, NULL, NULL);
    else { SDL_SetRenderDrawColor(render, 30,30,30,255); SDL_RenderClear(render); }

    // título
    SDL_Texture *t = cria_textura_texto("Jogo da Sustentabilidade", (SDL_Color){255,255,255,255});
    if (t) {
        int w,h; SDL_QueryTexture(t, NULL, NULL, &w, &h);
        SDL_Rect rt = { (LARG-w)/2, 80, w, h };
        SDL_RenderCopy(render, t, NULL, &rt);
        SDL_DestroyTexture(t);
    }

    // botões (usar texturas ou texto)
    desenhar_botao_com_textura(tex_btn_play, "Jogar (Quiz)", r_play);
    desenhar_botao_com_textura(tex_btn_tema_agua, "Água", r_tema_agua);
    desenhar_botao_com_textura(tex_btn_tema_energia, "Energia", r_tema_energia);
    desenhar_botao_com_textura(tex_btn_tema_meio, "Meio Ambiente", r_tema_meio);

    SDL_RenderPresent(render);
}

void renderizar_tema(Estado tema) {
    // escolher tile
    SDL_Texture *tile = NULL;
    const char *titulo = "";
    if (tema == EST_TEMA_AGUA) { tile = tex_tile_agua; titulo = "Tema: Água"; }
    else if (tema == EST_TEMA_ENERGIA) { tile = tex_tile_energia; titulo = "Tema: Energia"; }
    else if (tema == EST_TEMA_MEIO) { tile = tex_tile_meio; titulo = "Tema: Meio Ambiente"; }

    if (tile) SDL_RenderCopy(render, tile, NULL, NULL);
    else { SDL_SetRenderDrawColor(render, 30,30,30,255); SDL_RenderClear(render); }

    SDL_Texture *t = cria_textura_texto(titulo, (SDL_Color){255,255,255,255});
    if (t) {
        int w,h; SDL_QueryTexture(t, NULL, NULL, &w, &h);
        SDL_Rect rt = { (LARG-w)/2, 60, w, h };
        SDL_RenderCopy(render, t, NULL, &rt);
        SDL_DestroyTexture(t);
    }

    // botão voltar
    desenhar_botao_com_textura(tex_btn_voltar, "Voltar", r_voltar);
    SDL_RenderPresent(render);
}

// vídeo educativo (mostra tile_menu por baixo, botão voltar funciona)
void video_educativo() {
    SDL_Event e;
    bool sair = false;

    Uint32 start = SDL_GetTicks();
    while (!sair) {
        while (SDL_WaitEventTimeout(&e, TIMEOUT_MS)) {
            if (e.type == SDL_QUIT) { exit(0); }
            if (e.type == SDL_KEYDOWN) {
                if (e.key.keysym.sym == SDLK_ESCAPE) { sair = true; break; }
                // voltar por teclado
                if (e.key.keysym.sym == SDLK_BACKSPACE) { sair = true; break; }
            }
            if (e.type == SDL_MOUSEBUTTONDOWN) {
                int mx = e.button.x, my = e.button.y;
                if (dentro_rect(r_voltar, mx, my)) { sair = true; break; }
            }
        }

        // desenha
        if (tex_tile_menu) SDL_RenderCopy(render, tex_tile_menu, NULL, NULL);
        else { SDL_SetRenderDrawColor(render, 10,10,10,255); SDL_RenderClear(render); }

        // simular vídeo com barra de progresso
        Uint32 t = (SDL_GetTicks() - start);
        int progresso = (int)((t % 5000) / 5000.0f * (LARG-200));
        SDL_Rect barra = {100, 350, progresso, 30};
        SDL_SetRenderDrawColor(render, 50,150,200,255);
        SDL_RenderFillRect(render, &barra);

        // instrução e botão voltar
        SDL_Texture *txt = cria_textura_texto("[VIDEO EDUCATIVO SIMULADO] - Clique em Voltar ou pressione ESC para sair", (SDL_Color){255,255,255,255});
        if (txt) {
            int w,h; SDL_QueryTexture(txt, NULL, NULL, &w, &h);
            SDL_Rect rt = { (LARG-w)/2, 250, w, h };
            SDL_RenderCopy(render, txt, NULL, &rt);
            SDL_DestroyTexture(txt);
        }

        desenhar_botao_com_textura(tex_btn_voltar, "Voltar", r_voltar);

        SDL_RenderPresent(render);
        SDL_Delay(16);
    }
}

// -------------------------
// Inicialização / Cleanup
// -------------------------
bool inicializar_audio() {
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024) < 0) {
        fprintf(stderr, "Mix_OpenAudio erro: %s\n", Mix_GetError());
        return false;
    }
    // sons opcionais (se existirem)
    som_certo = Mix_LoadWAV("assets/som_certo.wav");
    som_errado = Mix_LoadWAV("assets/som_errado.wav");
    // se falhar, apenas não tocar
    return true;
}

void liberar_recursos() {
    if (som_certo) Mix_FreeChunk(som_certo);
    if (som_errado) Mix_FreeChunk(som_errado);
    Mix_CloseAudio();

    #define DEST(t) if(t){SDL_DestroyTexture(t); t=NULL;}
    DEST(tex_tile_menu); DEST(tex_tile_agua); DEST(tex_tile_energia); DEST(tex_tile_meio);
    DEST(tex_btn_play); DEST(tex_btn_voltar); DEST(tex_btn_tema_agua); DEST(tex_btn_tema_energia);
    DEST(tex_btn_tema_meio); DEST(tex_btn_sim); DEST(tex_btn_nao);
    #undef DEST

    if (fonte) { TTF_CloseFont(fonte); fonte = NULL; }
    if (render) { SDL_DestroyRenderer(render); render = NULL; }
    if (janela) { SDL_DestroyWindow(janela); janela = NULL; }

    IMG_Quit();
    TTF_Quit();
    SDL_Quit();
}

// -------------------------
// MAIN
// -------------------------
int main(int argc, char **argv) {
    srand((unsigned)time(NULL));

    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0) {
        fprintf(stderr, "SDL_Init erro: %s\n", SDL_GetError());
        return 1;
    }
    if (!(IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG)) {
        fprintf(stderr, "IMG_Init erro: %s\n", IMG_GetError());
        // continua, é apenas aviso
    }
    if (TTF_Init() != 0) {
        fprintf(stderr, "TTF_Init erro: %s\n", TTF_GetError());
        SDL_Quit();
        return 1;
    }

    janela = SDL_CreateWindow("Jogo Sustentabilidade", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, LARG, ALT, 0);
    if (!janela) { fprintf(stderr, "CreateWindow erro: %s\n", SDL_GetError()); TTF_Quit(); SDL_Quit(); return 1; }
    render = SDL_CreateRenderer(janela, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!render) { fprintf(stderr, "CreateRenderer erro: %s\n", SDL_GetError()); SDL_DestroyWindow(janela); TTF_Quit(); SDL_Quit(); return 1; }

    // fonte com acentos (UTF-8)
    const char *fontfile = "assets/DejaVuSans.ttf";
    fonte = TTF_OpenFont(fontfile, 28);
    if (!fonte) {
        fprintf(stderr, "Não abriu fonte '%s': %s\nTentando fallback 'assets/FreeSans.ttf'...\n", fontfile, TTF_GetError());
        fonte = TTF_OpenFont("assets/FreeSans.ttf", 28);
        if (!fonte) fprintf(stderr, "Falha ao abrir fonte fallback: %s\n", TTF_GetError());
    }

    // inicializar áudio (opcional)
    inicializar_audio();

    // carregar texturas uma vez
    tex_tile_menu = carregar_textura("assets/tile_menu.png");
    tex_tile_agua = carregar_textura("assets/tile_agua.png");
    tex_tile_energia = carregar_textura("assets/tile_energia.png");
    tex_tile_meio = carregar_textura("assets/tile_meioambiente.png");

    tex_btn_play = carregar_textura("assets/botao_play.png");
    tex_btn_voltar = carregar_textura("assets/botao_voltar.png");
    tex_btn_tema_agua = carregar_textura("assets/botao_agua.png");
    tex_btn_tema_energia = carregar_textura("assets/botao_energia.png");
    tex_btn_tema_meio = carregar_textura("assets/botao_meioambiente.png");
    tex_btn_sim = carregar_textura("assets/botao_sim.png");
    tex_btn_nao = carregar_textura("assets/botao_nao.png");

    // criar perguntas exemplo
    criar_perguntas_exemplos();

    // estado inicial
    Estado estado = EST_MENU;
    SDL_Event e;

    // desenha menu inicial
    renderizar_menu();

    while (estado != EST_QUIT) {
        // usar wait timeout para economizar CPU e permitir "frame" re-draw quando necessário
        if (SDL_WaitEventTimeout(&e, TIMEOUT_MS)) {
            if (e.type == SDL_QUIT) { estado = EST_QUIT; break; }

            if (e.type == SDL_MOUSEBUTTONDOWN) {
                int mx = e.button.x, my = e.button.y;

                if (estado == EST_MENU) {
                    if (dentro_rect(r_play, mx, my)) {
                        // antes de iniciar quiz, desenha fundo do menu e mantém
                        if (tex_tile_menu) SDL_RenderCopy(render, tex_tile_menu, NULL, NULL);
                        else { SDL_SetRenderDrawColor(render, 30,30,30,255); SDL_RenderClear(render); }
                        renderizar_menu();
                        // inicia quiz geral (exemplo usa tema água como demo)
                        // aqui o usuário escolhe qual quiz; para demo, abrir menu de seleção:
                        // simples: perguntar por qual tema pelo clique nos botões de tema
                        // mas neste fluxo, jogar quiz do menu → usamos água por exemplo
                        int pts = executar_quiz_com_tile(tex_tile_menu, "Quiz Geral (Menu)", perguntas_agua);
                        // após quiz, redesenhar menu e mostrar pontuação por curto tempo (feito dentro)
                        renderizar_menu();
                    }
                    else if (dentro_rect(r_tema_agua, mx, my)) {
                        // desenha tile do tema antes de qualquer ação
                        renderizar_tema(EST_TEMA_AGUA);
                        // agora pode iniciar quiz OU apenas mostrar informação; escolha: iniciar quiz
                        int pts = executar_quiz_com_tile(tex_tile_agua, "Quiz - Água", perguntas_agua);
                        // ao retornar do quiz, mantém o tile do tema (executar_quiz espera o Voltar)
                        renderizar_menu(); // volta ao menu
                    }
                    else if (dentro_rect(r_tema_energia, mx, my)) {
                        renderizar_tema(EST_TEMA_ENERGIA);
                        int pts = executar_quiz_com_tile(tex_tile_energia, "Quiz - Energia", perguntas_energia);
                        renderizar_menu();
                    }
                    else if (dentro_rect(r_tema_meio, mx, my)) {
                        renderizar_tema(EST_TEMA_MEIO);
                        int pts = executar_quiz_com_tile(tex_tile_meio, "Quiz - Meio Ambiente", perguntas_meio);
                        renderizar_menu();
                    }
                } // fim EST_MENU

                // botao voltar nas páginas de tema e vídeo é tratado dentro das funções que desenham essas páginas
            } // fim mousebuttondown

            if (e.type == SDL_KEYDOWN) {
                if (estado == EST_MENU) {
                    if (e.key.keysym.sym == SDLK_ESCAPE) { estado = EST_QUIT; break; }
                }
            }
        } // fim waitEventTimeout

        // re-desenhar menu periodicamente se estiver no menu (mantém animação estável)
        // (a função renderizar_menu já faz SDL_RenderPresent)
        // Podemos colocar pequeno delay para limitar CPU:
        SDL_Delay(8);
    } // fim while principal

    liberar_recursos();
    return 0;
}
